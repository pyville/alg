# 알고리즘

[돌아가기](/../alg/)

출처: 파이썬 알고리즘 인터뷰

## 재귀

재귀(Recursive) 함수란 함수의 실행 과정에서 자기 자신을 호출하는 함수입니다. 전체 문제를 하위 문제들로 나눌 수 있으면 (수학의 관점에서, 점화식으로 표현할 수 있으면) 재귀함수를 사용하여 풀이할 수 있습니다.

재귀함수의 문제점은 하나의 함수가 재귀 호출을 여러 번 하도록 설정한 경우 함수의 호출이 기하급수적으로 늘어난다는 점입니다.

다음 그림은 피보나치 수열의 일반항을 재귀함수로 구현한 것입니다.

> fib(n) = fib(n-1) + fib(n-2)

## 탐욕법

탐욕법, 또는 그리디(Greedy) 알고리즘이란 매 순간 최적의 선택을 할 때 최종적인 해답에 도달할 수 있는 방법입니다(부분해가 최적해가 되는 마법). 탐욕법으로 풀 수 있는 문제는 일반적으로 동적 계획법으로도 풀 수 있지만, 그 역은 성립하지 않습니다. 다음 조건을 만족하는 문제는 탐욕법으로 풀 수 있습니다.

- 탐욕 선택 조건(Greedy Choice Property): 앞에서 한 선택이 이후 선택에 영향을 주지 않음
- 최적의 부분 구조(Optimal Substructure): 문제에 대한 최적해가 부분문제에 대해서도 최적해

## 동적 계획법

동적 계획법, 또는 다이나믹 프로그래밍(Dynamic Programming; DP)란 문제를 각각의 작은 문제로 쪼개어 해결한 결과를 점차적으로 합쳐 전체 문제의 결과를 얻어내는 알고리즘입니다. 다음 조건을 만족하는 문제는 동적 계획법으로 풀 수 있습니다.

- 최적의 부분 구조(Optimal Substructure): 문제에 대한 최적해가 부분문제에 대해서도 최적해
- 겹치는 하위 문제(Overlapping Subproblems): 한 문제를 푸는 데 같은 하위 문제를 여러 번 풀게 됨

동적 계획법의 방법에는 메모이제이션(하향식 접근법) 및 타뷸레이션(상향식 접근법)이 있습니다.

## 탐색 알고리즘

원하는 특정 값의 위치를 찾기 위한 알고리즘입니다.

- 순차 탐색(완전 탐색)

    원하는 값을 찾기 위해 모든 값을 전부 조사하는 것입니다. 브루트 포스(Brute-force)라고도 합니다. 

    시간 복잡도는 **O(n)**인데, 높은 효율성 기준을 충족할 것을 요구하는 코딩 테스트 문제에서는 사용할 수 없습니다.

- 이진 탐색

    원하는 값을 찾기 위해 반씩 나누어서 찾는 작업을 반복합니다. 기본적으로 데이터가 정렬되어 있어야 합니다. 

    시간 복잡도는 **O(lg n)**입니다.

## 정렬 알고리즘

리스트 등 순서가 있는 콜렉션 자료형의 경우, 값을 특정한 기준에 의해 정렬할 필요가 생깁니다. 이 때 사용하는 알고리즘입니다.

- 선택 정렬

    모든 값을 순회하면서 가장 작은 원소, 그 다음으로 가장 작은 원소, ... 를 순회하는 것입니다. 가장 작은 원소는 0번째 원소, 그 다음으로 작은 원소는 1번째 원소, ... 와 위치를 교환합니다.

    for 문을 2개 중첩하여 사용하며, 시간 복잡도는 **O(n^2)**로 권장되지 않습니다.

- 삽입 정렬

    모든 값을 순회하면서 가장 작은 원소, 그 다음으로 가장 작은 원소, ... 를 순회하는 것입니다. i번째 원소는 이미 정렬된 원소들 중 적당한 위치에 들어갑니다. 단, i번째 원소를 순회할 때 그 앞의 원소들은 모두 정렬되어 있다고 간주합니다.

    역시 for 문을 2개 중첩하여 사용하며, 시간 복잡도는 **O(n^2)**로 권장되지 않습니다.

- 거품 정렬

- 퀵 정렬

    적당한 값을 pivot으로 설정한 이후, pivot을 기준으로 큰 값과 작은 값으로 나눕니다. 이 과정을 재귀적으로 반복하여 정렬하는 방법입니다.

    시간 복잡도는 일반적인 경우 **O(n lg n)**이지만, pivot의 값에 따라 최악의 경우 **O(n^2)**입니다.

- 병합 정렬

    이진 탐색을 하듯이, 한 리스트를 재귀적으로 반씩 나누고, 최소 단위에서 정렬한 다음 다시 합치면서 정렬하는 방법입니다.

    시간 복잡도는 **O(n lg n)**으로 가장 빠른 정렬 알고리즘 중 하나입니다.

# 시간 복잡도

컴퓨터가 일을 처리하는 시간이 다 비슷할 거라고 생각하기 쉽지만, 일이 많으면 시간이 더 걸리는 것은 당연한 일입니다. 또한 이는 알고리즘의 종류나 데이터의 상태에 따라서 크게 달라집니다. 이를 **시간 복잡도**(time complexity)라고 부르며, n에 대한 식으로 나타냅니다.

이때 계수, 차수가 낮은 항, 상수항 등을 생략하고 $**O(n)**, **O(n^2)** 등으로 간단하게 나타냅니다. 이를 big-O 표기법이라고 합니다.